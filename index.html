
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>P.O.P.S. Protocol Visualizer — Offline→Online Flow Map</title>
<meta name="description" content="Interactive, offline-first AppDrop that visualizes the P.O.P.S. protocol pipeline: Roger AI, Snake Eyes cache, Engine Emulator, Panel Layer, and Online/Sync." />
<style>
  :root{
    --bg:#0a0f1a; --panel:#0e1526; --ink:#e7ebff; --muted:#9da9d9; --edge:#1f2947;
    --accent:#6cf5ff; --accent2:#c28bff; --good:#67ffa1; --warn:#ffd36c; --danger:#ff7e9e;
    --glass: rgba(255,255,255,0.06); --glass-2: rgba(255,255,255,0.12);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 600px at 20% 0%, #0f1629, var(--bg));color:var(--ink);font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
  .hud{position:sticky; top:0; z-index:9; display:flex; gap:.75rem; align-items:center; padding:.75rem .9rem; backdrop-filter:saturate(1.4) blur(8px); background:linear-gradient(180deg, rgba(15,22,41,.8), rgba(15,22,41,.45)); border-bottom:1px solid var(--edge); box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .hud h1{font-size:1rem; margin:0; letter-spacing:.3px; color:var(--accent)}
  .hud .pill{display:flex; align-items:center; gap:.5rem; background:var(--glass); border:1px solid var(--edge); padding:.5rem .6rem; border-radius:999px}
  .hud .pill label{font-size:.8rem;color:var(--muted)}
  .hud select,.hud button,.hud input[type="checkbox"], .hud input[type="range"]{accent-color:var(--accent)}
  .hud button{border:1px solid var(--edge); background:linear-gradient(180deg, #0f1a33, #0a1226); color:var(--ink); padding:.55rem .8rem; border-radius:12px; cursor:pointer}
  .hud button:hover{box-shadow:0 0 0 1px var(--accent), 0 0 18px rgba(108,245,255,.25)}
  .layout{display:grid; grid-template-columns: 1fr 360px; gap:.75rem; padding:.75rem}
  .card{background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.025)); border:1px solid var(--edge); border-radius:16px; box-shadow:inset 0 0 0 1px rgba(255,255,255,.03), 0 10px 30px rgba(0,0,0,.25)}
  .stage{position:relative; height: calc(100vh - 110px); overflow:hidden}
  .sidebar{display:flex; flex-direction:column; gap:.75rem}
  .pane{padding: .8rem}
  .pane h2{margin:.2rem 0 .6rem; font-size:.95rem; color:var(--muted)}
  .kv{display:grid; grid-template-columns: 120px 1fr; gap:.3rem .5rem; font-size:.85rem}
  .badge{display:inline-flex; align-items:center; gap:.4rem; padding:.2rem .5rem; border-radius:999px; border:1px solid var(--edge); background:var(--glass)}
  .badge.good{color:#003b22; background:#67ffa11c; border-color:#2f6}
  .badge.warn{color:#4d3b00; background:#ffd36c1c; border-color:#fc6}
  .badge.danger{color:#4d0010; background:#ff7e9e1c; border-color:#f78}
  .log{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:.82rem; background: #0b1222; color:#cfe2ff; padding:.6rem; height:220px; overflow:auto; border-radius:12px; border:1px solid var(--edge)}
  .json{white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.8rem; background:#0b1222; padding:.6rem; border-radius:12px; border:1px solid var(--edge); color:#d9e7ff}
  .foot{padding:.5rem .9rem; text-align:center; color:var(--muted); font-size:.75rem}

  /* Graph styling */
  svg{width:100%; height:100%}
  .groot{transform-origin:0 0}
  .node{cursor:pointer}
  .node rect{fill:url(#nodeGrad); stroke:var(--edge); stroke-width:1.2}
  .node .title{font-weight:700; letter-spacing:.25px}
  .node .subtitle{fill:var(--muted)}
  .node.active rect{stroke:var(--accent); filter:url(#glow)}
  .edge{stroke:#7ca6ff; stroke-opacity:.75; fill:none}
  .edge-bg{stroke:rgba(255,255,255,.07); stroke-width:9; fill:none}
  .edge-arrow{fill:#7ca6ff}
  .pulse{animation:pulse 1.3s ease-out 1}
  @keyframes pulse {0%{filter:drop-shadow(0 0 0 rgba(108,245,255,0.0));}50%{filter:drop-shadow(0 0 12px rgba(108,245,255,0.7));}100%{filter:drop-shadow(0 0 0 rgba(108,245,255,0.0));}}

  /* Tips overlay */
  .tips{position:absolute; left:12px; bottom:12px; padding:.4rem .6rem; font-size:.8rem; color:var(--muted); background:var(--glass); border:1px solid var(--edge); border-radius:10px}
</style>
</head>
<body>
  <div class="hud">
    <h1>P.O.P.S. Protocol Visualizer</h1>
    <div class="pill">
      <label for="scenario">Scenario</label>
      <select id="scenario">
        <option value='{"appdrop":"bryce_drivein","media":"bryce_intro.mp4"}'>Play Bryce Drive‑In (mp4)</option>
        <option value='{"appdrop":"magifico","media":"rabbit_trick.webm"}'>Open Magifico + trick (webm)</option>
        <option value='{"appdrop":"northern_lights","media":"aurora_playlist.m3u"}'>Northern Lights playlist</option>
      </select>
    </div>
    <div class="pill">
      <label>Offline mode</label>
      <input id="offline" type="checkbox" checked />
    </div>
    <div class="pill">
      <label>Allow online fallback</label>
      <input id="allowOnline" type="checkbox" checked />
    </div>
    <div class="pill">
      <label>Asset cached</label>
      <select id="cacheLevel">
        <option value="hot">Hot</option>
        <option value="warm">Warm</option>
        <option value="cold">Cold</option>
        <option value="none" selected>None</option>
      </select>
    </div>
    <div class="pill">
      <label>Speed</label>
      <input id="speed" type="range" min="0.4" max="2.2" step="0.1" value="1" />
    </div>
    <button id="run">▶ Run Flow</button>
    <button id="reset">↺ Reset</button>
  </div>

  <div class="layout">
    <div class="card stage">
      <svg id="svgel" viewBox="0 0 1600 960" aria-label="Protocol Map">
        <defs>
          <linearGradient id="nodeGrad" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#0e1b37"/>
            <stop offset="100%" stop-color="#0a1224"/>
          </linearGradient>
          <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7" markerHeight="7" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" class="edge-arrow" />
          </marker>
        </defs>
        <g id="groot" class="groot">
          <!-- edges bg then fg for hit/contrast -->
          <g id="edges-bg"></g>
          <g id="edges"></g>
          <!-- nodes -->
          <g id="nodes"></g>
        </g>
      </svg>
      <div class="tips">Scroll to zoom • drag background to pan • click a node for details • double‑click background to reset view</div>
    </div>

    <div class="sidebar">
      <div class="card pane">
        <h2>Node Inspector</h2>
        <div class="kv" id="inspector">
          <div>Id</div><div id="n_id">—</div>
          <div>Title</div><div id="n_title">—</div>
          <div>Role</div><div id="n_role">—</div>
          <div>Layer</div><div id="n_layer">—</div>
          <div>Status</div><div id="n_status"><span class="badge">Idle</span></div>
        </div>
      </div>
      <div class="card pane">
        <h2>Protocol Payload</h2>
        <div class="json" id="payload">{}</div>
      </div>
      <div class="card pane">
        <h2>Event Log</h2>
        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

  <div class="foot">P.O.P.S. Protocol Blueprint — AppDrop, fully offline • v1.0</div>

<script>
(function(){
  const svg = document.getElementById('svgel');
  const g = document.getElementById('groot');
  const gEdges = document.getElementById('edges');
  const gEdgesBG = document.getElementById('edges-bg');
  const gNodes = document.getElementById('nodes');
  const inspector = {
    id: document.getElementById('n_id'),
    title: document.getElementById('n_title'),
    role: document.getElementById('n_role'),
    layer: document.getElementById('n_layer'),
    status: document.getElementById('n_status')
  };
  const logEl = document.getElementById('log');
  const payloadEl = document.getElementById('payload');

  const controls = {
    scenario: document.getElementById('scenario'),
    offline: document.getElementById('offline'),
    allowOnline: document.getElementById('allowOnline'),
    cacheLevel: document.getElementById('cacheLevel'),
    speed: document.getElementById('speed'),
    run: document.getElementById('run'),
    reset: document.getElementById('reset')
  };

  const NODES = [
    {id:'user', title:'User Layer', role:'Panels • Gestures • Voice', layer:'UX', x:130, y:80, w:260, h:90},
    {id:'roger', title:'Roger AI', role:'Intent parsing • Routing', layer:'AI Command', x:450, y:80, w:260, h:90},

    {id:'cache', title:'Snake Eyes Cache', role:'Hot • Warm • Cold', layer:'Local Cache', x:450, y:240, w:260, h:100},
    {id:'online', title:'Online Layer', role:'CDN • Peer Sync', layer:'Network', x:760, y:240, w:260, h:100},
    {id:'fetcher', title:'Cloud Resource Fetcher', role:'AppDrop + Media Store', layer:'Network', x:1070, y:240, w:300, h:100},

    {id:'engine', title:'Engine Emulator', role:'AppDrop Loader • Media Pipeline', layer:'Runtime', x:760, y:430, w:260, h:100},
    {id:'panel', title:'Panel Experience Layer', role:'UI Render • Media View', layer:'UX', x:1070, y:430, w:300, h:100},

    {id:'state', title:'Local State + Sync', role:'Prefs • Deltas • Versions', layer:'State', x:760, y:620, w:260, h:100}
  ];

  // Simplified directed edges
  const EDGES = [
    e('user','roger'),
    e('roger','cache'),
    e('roger','online'),
    e('online','fetcher'),
    e('fetcher','cache'),
    e('cache','engine'),
    e('engine','panel'),
    e('panel','state'),
    e('state','online') // delta sync when online
  ];
  function e(from,to){ return {id:`${from}_${to}` , from, to}; }

  // Build node map
  const nodeById = new Map(NODES.map(n=>[n.id,n]));

  // Layout helpers
  function draw(){
    gNodes.innerHTML = '';
    gEdges.innerHTML = '';
    gEdgesBG.innerHTML = '';
    // Edges first (bg then fg)
    for(const ed of EDGES){
      const p = edgePath(ed.from, ed.to);
      const bg = pathEl(p, 'edge-bg'); bg.setAttribute('stroke-width','8');
      gEdgesBG.appendChild(bg);
      const fg = pathEl(p, 'edge'); fg.setAttribute('marker-end','url(#arrow)'); fg.dataset.id = ed.id;
      gEdges.appendChild(fg);
    }
    // Nodes
    for(const n of NODES){
      const gnode = document.createElementNS('http://www.w3.org/2000/svg','g');
      gnode.classList.add('node'); gnode.dataset.id = n.id;
      const r = rect(n.x, n.y, n.w, n.h, 16);
      gnode.appendChild(r);
      const title = text(n.x + n.w/2, n.y + 32, n.title, 'middle'); title.classList.add('title'); title.setAttribute('font-size','15');
      const sub = text(n.x + n.w/2, n.y + 60, n.role, 'middle'); sub.classList.add('subtitle'); sub.setAttribute('font-size','12');
      const layer = text(n.x + n.w/2, n.y + n.h - 14, n.layer, 'middle'); layer.setAttribute('font-size','11'); layer.setAttribute('fill','#8fb4ff');
      gnode.appendChild(title); gnode.appendChild(sub); gnode.appendChild(layer);
      gnode.addEventListener('click', ()=> selectNode(n.id));
      gNodes.appendChild(gnode);
    }
  }

  function rect(x,y,w,h,rx){
    const el = document.createElementNS('http://www.w3.org/2000/svg','rect');
    el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('width',w); el.setAttribute('height',h); el.setAttribute('rx',rx);
    return el;
  }
  function text(x,y,content,anchor){
    const el = document.createElementNS('http://www.w3.org/2000/svg','text');
    el.setAttribute('x',x); el.setAttribute('y',y); el.setAttribute('text-anchor',anchor||'start');
    el.textContent = content; return el;
  }
  function pathEl(d, cls){ const el = document.createElementNS('http://www.w3.org/2000/svg','path'); el.setAttribute('d',d); if(cls) el.setAttribute('class',cls); return el; }
  function center(n){ return { cx: n.x + n.w/2, cy: n.y + n.h/2}; }
  function edgePath(a,b){
    const A = nodeById.get(a), B = nodeById.get(b);
    const cA = center(A), cB = center(B);
    // route: horizontal/vertical dogleg based on relative position
    const midX = (cA.cx + cB.cx)/2;
    const d = `M ${cA.cx} ${cA.cy} C ${midX} ${cA.cy}, ${midX} ${cB.cy}, ${cB.cx} ${cB.cy}`;
    return d;
  }

  // Inspector
  function selectNode(id){
    for(const el of gNodes.querySelectorAll('.node')) el.classList.remove('active');
    const nodeEl = gNodes.querySelector(`[data-id="${id}"]`);
    if(nodeEl){ nodeEl.classList.add('active'); nodeEl.classList.add('pulse'); setTimeout(()=>nodeEl.classList.remove('pulse'),900); }
    const n = nodeById.get(id);
    inspector.id.textContent = n.id;
    inspector.title.textContent = n.title;
    inspector.role.textContent = n.role;
    inspector.layer.textContent = n.layer;
  }

  // Pan + Zoom
  let zoom = 1, tx = 0, ty = 0;
  let dragging = false, lx=0, ly=0;
  function applyTransform(){ g.style.transform = `translate(${tx}px,${ty}px) scale(${zoom})`; }
  svg.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.08;
    const prev = zoom;
    zoom = Math.min(2.5, Math.max(0.5, zoom + delta));
    // zoom towards cursor
    const pt = svgPoint(e.clientX, e.clientY);
    tx = pt.x - (pt.x - tx) * (zoom/prev);
    ty = pt.y - (pt.y - ty) * (zoom/prev);
    applyTransform();
  }, {passive:false});
  svg.addEventListener('pointerdown', (e)=>{ if(e.target.closest('#nodes')) return; dragging=true; lx=e.clientX; ly=e.clientY; svg.setPointerCapture(e.pointerId); });
  svg.addEventListener('pointermove', (e)=>{ if(!dragging) return; tx += e.clientX-lx; ty += e.clientY-ly; lx=e.clientX; ly=e.clientY; applyTransform(); });
  svg.addEventListener('pointerup', ()=> dragging=false);
  svg.addEventListener('dblclick', ()=>{ zoom=1; tx=0; ty=0; applyTransform(); });
  function svgPoint(cx,cy){ const rect = svg.getBoundingClientRect(); return {x: cx-rect.left, y: cy-rect.top}; }

  // Logging
  function log(msg, type){
    const t = new Date().toLocaleTimeString();
    const color = type==='warn'? '#ffd36c' : type==='err'? '#ff7e9e' : '#a7ffcf';
    const line = document.createElement('div');
    line.innerHTML = `<span style="color:${color}">[${t}]</span> ${msg}`;
    logEl.appendChild(line); logEl.scrollTop = logEl.scrollHeight;
  }
  function clearLog(){ logEl.innerHTML = ''; }

  // Flow animation
  let animAbort = null;
  async function animatePath(edgeIds, speed=1){
    abortAnimation();
    const restore = [];
    animAbort = { stop:false };
    for(const id of edgeIds){
      if(animAbort.stop) break;
      const edge = gEdges.querySelector(`[data-id="${id}"]`);
      if(!edge) continue;
      const len = edge.getTotalLength();
      edge.style.strokeDasharray = len;
      edge.style.strokeDashoffset = len;
      edge.style.transition = 'none';
      // pulse source node
      const [from] = id.split('_');
      pulseNode(from);
      await raf();
      await sleep(20);
      // animate
      edge.style.transition = `stroke-dashoffset ${Math.max(250, len)}ms linear`;
      edge.style.strokeDashoffset = '0';
      restore.push(()=>{ edge.style.transition=''; edge.style.strokeDasharray=''; edge.style.strokeDashoffset=''; });
      await sleep(Math.max(350, len/1.2) / speed);
    }
    // pulse last node
    const last = edgeIds[edgeIds.length-1]; if(last){ pulseNode(last.split('_')[1]); }
    return ()=> restore.forEach(fn=>fn());
  }
  function abortAnimation(){ if(animAbort){ animAbort.stop = true; animAbort=null; for(const p of gEdges.querySelectorAll('path')){ p.style.transition=''; p.style.strokeDasharray=''; p.style.strokeDashoffset=''; } } }
  function pulseNode(id){ const el = gNodes.querySelector(`[data-id="${id}"]`); if(el){ el.classList.add('pulse'); setTimeout(()=>el.classList.remove('pulse'), 900); } }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  function raf(){ return new Promise(r=>requestAnimationFrame(()=>r())); }

  // Scenario computation → list of edge ids representing the flow
  function computeFlow(opts){
    const edges = [];
    // User to Roger always
    edges.push('user_roger');
    const cached = opts.cacheLevel !== 'none';
    const offline = opts.offline;
    const allowOnline = opts.allowOnline;

    if(offline){
      // try cache first
      edges.push('roger_cache');
      if(cached){
        edges.push('cache_engine','engine_panel','panel_state');
        if(allowOnline){ // even offline mode may push deltas later
          // no immediate online push
        }
      } else {
        if(allowOnline){
          // fallback to online path
          edges.push('roger_online','online_fetcher','fetcher_cache','cache_engine','engine_panel','panel_state','state_online');
        } else {
          // stay offline and fail gracefully (stop at cache)
          // we still show attempted path to cache
        }
      }
    } else {
      // hybrid/online-first flavor: if cached, still use cache path; otherwise go online
      if(cached){
        edges.push('roger_cache','cache_engine','engine_panel','panel_state','state_online');
      } else {
        edges.push('roger_online','online_fetcher','fetcher_cache','cache_engine','engine_panel','panel_state','state_online');
      }
    }
    return edges;
  }

  function buildPayload(){
    const scenario = JSON.parse(controls.scenario.value);
    const payload = {
      protocol: 'POPS-PanelSync-1.0',
      priority: 'offline-first',
      request: { source:'Roger', command:'loadAppDrop', target: scenario.appdrop, media: scenario.media },
      cache_strategy: { level: controls.cacheLevel.value, fallback_online: controls.allowOnline.checked },
      stream_mode: 'dual-panel',
      sync: { enabled: true, method: 'delta' },
      feedback: { roger_message: 'Ready', panel_update: true, save_state: true }
    };
    payloadEl.textContent = JSON.stringify(payload, null, 2);
    return payload;
  }

  async function run(){
    clearLog(); buildPayload();
    const opts = {
      offline: controls.offline.checked,
      allowOnline: controls.allowOnline.checked,
      cacheLevel: controls.cacheLevel.value,
      speed: parseFloat(controls.speed.value)
    };
    log(`Scenario: ${controls.scenario.options[controls.scenario.selectedIndex].text}`);
    log(`Mode: ${opts.offline? 'Offline' : 'Hybrid/Online'} • Cache: ${opts.cacheLevel} • Online fallback: ${opts.allowOnline}`);

    const path = computeFlow(opts);
    if(opts.offline && opts.cacheLevel==='none' && !opts.allowOnline){
      log('Cache miss while offline. Serving graceful fallback (UI + prompts, no media).','warn');
      // animate partial path
      await animatePath(['user_roger','roger_cache'], opts.speed);
      pulseNode('panel'); log('Panel shows friendly offline message + allows user to retry.', 'warn');
      return;
    }

    log('Executing flow...');
    await animatePath(path, opts.speed);

    // Contextual logs
    if(path.includes('fetcher_cache')){
      log('Remote asset fetched and inserted into Hot cache ✔', '');
    }
    if(path.includes('state_online')){
      log('Delta state sync pushed to online layer ✔', '');
    }
    log('Flow complete.');
  }

  function reset(){
    abortAnimation(); clearLog(); payloadEl.textContent='{}';
    // deselect active node
    for(const el of gNodes.querySelectorAll('.node')) el.classList.remove('active');
    // reset transform
    zoom=1; tx=0; ty=0; g.style.transform='';
  }

  // Wire controls
  controls.run.addEventListener('click', run);
  controls.reset.addEventListener('click', reset);
  controls.scenario.addEventListener('change', buildPayload);
  controls.cacheLevel.addEventListener('change', buildPayload);
  controls.allowOnline.addEventListener('change', buildPayload);

  // Init
  draw(); buildPayload(); selectNode('roger');
})();
</script>
</body>
</html>
